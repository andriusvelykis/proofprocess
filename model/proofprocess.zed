\documentclass{article}
\usepackage{czt}

\begin{document}
\begin{zsection}
  \SECTION proofprocess \parents standard\_toolkit
\end{zsection}

\newcommand{\todo}[1]{\[\mbox{\textbf{TODO:~#1}}\]}

From \textsf{WhyM.vdmsl}, we are leaving out theory, conjecture, definition, context and focusing here 
on the $Attempt$ and $Proof$ strcutures only, in so far as determining the necessary annotations to go
around the actual proof within different provers. These contexts might be needed and shall be theorem
prover specific (e.g., see EVIDENCE below). For definition (or indeed TERMs), we might need to have 
it explicit here (e.g., even if with mural's indices like structure).

\begin{itemize}
	\item TERM: abstract notion of terms, maybe use Mural's indices if needed
	\item LOC: like CZT LocAnn (e.g., file name, start/end char position, line/col number, etc)
	\item PID: gives a unique id to proof reference. \todo{undecided if for pointer to proof step or to what?}
	\item NAME: name is a ``pointer'' usually from a theorem/conjecture name to be used for various purposes.
	\item INTENT: the WhyM tags
	\item EVIDENCE: abstract type for evidence-based proof results. Use a mapping for ZEves/Isabelle/ETC
	\item PROOSCRIPT: like name, it's a string, but could be realised as a free-type for proof language involved?
		e.g., $PS ::= Uses \ldata NAME \rdata | Apply \ldata NAME \cross TERM \rdata$ and so on.
\end{itemize}
\begin{zed}
    [TERM, LOC, PID, NAME, INTENT, TEXT, EVIDENCE, PROOFSCRIPT]
    \\
    ZEvesThmUsageTag ::= Use | Rule | GRule | FRule
\end{zed}

\begin{itemize}
	\item goal: an abstract reference to what's being proved. 
		hopefully there will be no need (or at least a controlled need) for knowing the underlying structure
		
	\item source: might be useful later for refinement when involving logging
	
	\item pid: uniqueness (e.g., same goal and evidence but for different proof cases)
	
	\item evidence: mapping from pointer (NAME) to proof tag
		depending on the tool/technique involved, different maps from NAME to proof reference or lemma database or tactics etc
		can be used to see what kind of evidence that name refers to. The proof tag result is a set of markers to say how was
		it possible to get to the goal? Or should we have two goals: original and changed through the chain of evidence? 
		
		in ZEves' case, the evidence map will be the used lemma names mapped to the tactics they've applied (e.g., use/apply/pbr/etc).
		\todo{Somewhere else, there is another map saying what kind of lemma each of these names were (E.g., rule, frule, grule, etc).}		
\end{itemize}
\begin{schema}{ProofRef}
	goal: TERM \\
	source: LOC \\
	pid: PID \\
	evidence: EVIDENCE
\end{schema}
\begin{description}
	\item we are seeing this as the local state of an overall proof attempt that leads to the complete proof of involved goals.
		there might be some needed assumption about how (changing) goals get to match how the prover handles them.
	
	\item \todo{what is this akin to what in WhyM.vdmsl? Conjecture to some extent?}
	
	\item in a way we are distancing ourselves a bit from WhyM here --- we are trying to bridge the two, given one is closer to
		domain modelling, the other to the actual (EMF) implementation. Hopefully they will match/agree in principle, if not in
		the underlying details.
\end{description}

\begin{itemize}
	\item For ZEves, the evidence needed is just the complete proof command name as a proof script
	\item The lemmas used with the appropriate usage tag
\end{itemize}
\begin{schema}{ZEvesEvidence}
	proofCommand: PROOFSCRIPT \\
	usedLemmas: NAME \pfun ZEvesThmUsageTag
\end{schema}
%
The next function maps all evidence to a uniquely determined $ZEvesEvidence$ schema.
This makes the $ProofRef$ above ZEves specific, ex:
%
\[
	ProofRef \implies zeves\_evidence~(evidence)
\]
% 
and then I get the ZEves' specific proof evidence. Similarly for others. The existence
of such a function is taken as given. It might not need to be bijective, though
%
\begin{axdef}
	zeves\_evidence: EVIDENCE \bij ZEvesEvidence
\end{axdef}
%
\begin{schema}{ZEvesProofRef}
   ProofRef \\
   ZEvesEvidence
\where
   zeves\_evidence~(evidence) = \theta ZEvesEvidence
\end{schema}

$INTENT$ might be instantiated to more concrete values/types later on.
\begin{schema}{Intent}
	tag: INTENT \\
	desc: TEXT
\end{schema}
%
Proof info is the intent behind some part of the attempt plus anything
else that might become relevant/necessary.
%
\begin{schema}{ProofInfo}
	Intent
	\\
	% some more stuff
\end{schema}
%
Proof properties might have in/out parameters. These properties are like
$commutes(Term1, Term2)$ or $sums(in2, in2, out4)$. They are boolean-valued
uninterpreted functions(?) with parameters. We tag the parameters with different
structures needed.
%
\begin{zed}
	PropParam ::= NameParam \ldata NAME \rdata \\
			\t1	| TermParam \ldata TERM \rdata %\\
			%\t1 | ????
\end{zed}
%
The property then is its tag and in/out params. 
\todo{where to attach them? At attempt or at yet to be defined "Definition" schema?}.
%
\begin{schema}{Property}
	tag: NAME \\
	in, out: \seq~PropParam
\end{schema}

To represent attempts, we describe a proof tree type:
\begin{itemize}
	\item leafs contain a proof reference --- to be specialised towards different tools
	\item nodes encode the ``language'' involving composition (as $\seq_1$) and parallelism (as $\power_1$)
		e.g., $\langle \{ PT1, PT2 \}, \{ PT3 \} \rangle$ is the sequential composition of proof trees within
			each set in parallel like  (PT1 || PT2) ; PT3.
	\item both have the corresponding intent that lead to what they generate
	\item \todo{We also had this $\seq_1~(\bag_1~ProofTree)$ for the case where $P1 || P1$}
	\item ...
	\item To enable more flexibility, we describe the type as a language with seq/par/leaf, and a new one 
		called decoarator: it decorates a tree with extra intent (e.g., when wanting to group things together
		or when wanting to have two intent info for a leaf.
		
	\item from WhyM, get attempt kind as a marked for the way the attempt is.
\end{itemize}
\begin{zed}
	% nice but limiting in the possible linguistics possibilities
	ProofTree0 ::= leaf0 \ldata ProofRef \cross ProofInfo \rdata \\
			\t1 | node0 \ldata \seq_1~(\power_1~ProofTree0) \cross ProofInfo \rdata 
	\\
	% for optional intent? Or just use null for it axiomatically?
	OptPI ::= NonePI | Some \ldata ProofInfo \rdata
	\\
	ProofTree ::= Leaf \ldata ProofRef \cross OptPI \rdata \\ % or just ProofInto? 
			\t1 | Seq \ldata (ProofTree \cross ProofTree) \cross OptPI \rdata \\
			\t1 | Par \ldata (ProofTree \cross ProofTree) \cross OptPI \rdata \\
			\t1 | Decor \ldata ProofTree \cross OptPI \rdata \\ % useful for multi-layered intent
			%\t1 | Group \ldata \power~ProofTree \cross OptPI \rdata \\ ??? but not ProofTree; then what?
			%\t1 | whatever else....	
	\\
	ProofStatus ::= Axiom | Ignore | Qed | Unfinished
	\\
	AttemptKind ::= Blind | Guided | Because \ldata ProofTree \rdata | Clue \ldata ProofTree \rdata
\end{zed}
%
And attempt captures the (sub-)proof-tree with intent 
\begin{itemize}
	\item the kind of attempt as in its relationship with the proof tree involved
	\item the proof-tree (might be incomplete) of the current attempt
	\item \todo{How about properties? Should they belong to an attempt or not? 
		There is a case for having them, yet we may suffer from this choice as it might
		clutter the information around needed to infer what's relevant. Definitions should
		have properties as well.}
\end{itemize}
%
\begin{schema}{Attempt}
	kind: AttemptKind \\
	pt: ProofTree
\end{schema}
%
A proof is a series of attempts with its original goal
%
\begin{itemize}
	\item atts: attempt sequence
	\item pstatus: 
	\item label: name for this proof script
	\item goal: original goal term
\end{itemize}
\begin{schema}{Proof}
	atts: \seq_1~Attempt \\
	pstatus: ProofStatus \\
	label: NAME \\
	goal: TERM
\end{schema}

TODO/TOTHINK
* duplicate attempts (with the same proof script): ask the user if this is just a replay or a fresh new attempt. assume it's
  replay, leave the user to choose/config it

\end{document}