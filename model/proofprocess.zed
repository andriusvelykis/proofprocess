\documentclass{article}
\usepackage{czt}

\begin{document}
\begin{zsection}
  \SECTION proofprocess \parents standard\_toolkit
\end{zsection}

\newcommand{\todo}[1]{\[\mbox{\textbf{TODO:~#1}}\]}

\begin{itemize}
	\item TERM: abstract notion of terms, maybe use Mural's indices if needed
	\item LOC: like CZT LocAnn (e.g., file name, start/end char position, line/col number, etc)
	\item PID: gives a unique id to proof reference. \todo{undecided if for pointer to proof step or to what?}
	\item NAME: name is a ``pointer'' usually from a theorem/conjecture name to be used for various purposes.
	\item INTENT: the WhyM tags
	\item EVIDENCE: abstract type for evidence-based proof results. Use a mapping for ZEves/Isabelle/ETC
	\item PROOSCRIPT: like name, it's a string, but could be realised as a free-type for proof language involved?
		e.g., $PS ::= Uses \ldata NAME \rdata | Apply \ldata NAME \cross TERM \rdata$ and so on.
\end{itemize}
\begin{zed}
    [TERM, LOC, PID, NAME, INTENT, TEXT, EVIDENCE, PROOFSCRIPT]
    \\
    ZEvesThmUsageTag ::= Use | Rule | GRule | FRule
\end{zed}

\begin{itemize}
	\item goal: an abstract reference to what's being proved. 
		hopefully there will be no need (or at least a controlled need) for knowing the underlying structure
		
	\item source: might be useful later for refinement when involving logging
	
	\item pid: uniqueness (e.g., same goal and evidence but for different proof cases)
	
	\item evidence: mapping from pointer (NAME) to proof tag
		depending on the tool/technique involved, different maps from NAME to proof reference or lemma database or tactics etc
		can be used to see what kind of evidence that name refers to. The proof tag result is a set of markers to say how was
		it possible to get to the goal? Or should we have two goals: original and changed through the chain of evidence? 
		
		in ZEves' case, the evidence map will be the used lemma names mapped to the tactics they've applied (e.g., use/apply/pbr/etc).
		\todo{Somewhere else, there is another map saying what kind of lemma each of these names were (E.g., rule, frule, grule, etc).}		
\end{itemize}
\begin{schema}{ProofRef}
	goal: TERM \\
	source: LOC \\
	pid: PID \\
	evidence: EVIDENCE
\end{schema}
\begin{description}
	\item we are seeing this as the local state of an overall proof attempt that leads to the complete proof of involved goals.
		there might be some needed assumption about how (changing) goals get to match how the prover handles them.
	
	\item \todo{what is this akin to what in WhyM.vdmsl? Conjecture to some extent?}
	
	\item in a way we are distancing ourselves a bit from WhyM here --- we are trying to bridge the two, given one is closer to
		domain modelling, the other to the actual (EMF) implementation. Hopefully they will match/agree in principle, if not in
		the underlying details.
\end{description}

\begin{itemize}
	\item For ZEves, the evidence needed is just the complete proof command name as a proof script
	\item The lemmas used with the appropriate usage tag
\end{itemize}
\begin{schema}{ZEvesEvidence}
	proofCommand: PROOFSCRIPT \\
	usedLemmas: NAME \pfun ZEvesThmUsageTag
\end{schema}
%
The next function maps all evidence to a uniquely determined $ZEvesEvidence$ schema.
This makes the $ProofRef$ above ZEves specific, ex:
%
\[
	ProofRef \implies zeves\_evidence~(evidence)
\]
% 
and then I get the ZEves' specific proof evidence. Similarly for others. The existence
of such a function is taken as given. It might not need to be bijective, though
%
\begin{axdef}
	zeves\_evidence: EVIDENCE \bij ZEvesEvidence
\end{axdef}
%
\begin{schema}{ZEvesProofRef}
   ProofRef \\
   ZEvesEvidence
\where
   zeves\_evidence~(evidence) = \theta ZEvesEvidence
\end{schema}

$INTENT$ might be instantiated to more concrete values/types later on.
\begin{schema}{Intent}
	tag: INTENT \\
	desc: TEXT
\end{schema}

\begin{schema}{ProofInfo}
	Intent
	\\
	% some more stuff
\end{schema}

To represent attempts, we describe a proof tree type:
\begin{itemize}
	\item leafs contain a proof reference --- to be specialised towards different tools
	\item nodes encode the ``language'' involving composition (as $\seq_1$) and parallelism (as $\power_1$)
		e.g., $\langle \{ PT1, PT2 \}, \{ PT3 \} \rangle$ is the sequential composition of proof trees within
			each set in parallel like  (PT1 || PT2) ; PT3.
	\item both have the corresponding intent that lead to what they generate
	\item \todo{We also had this $\seq_1~(\bag_1~ProofTree)$ for the case where $P1 || P1$}
\end{itemize}
\begin{zed}
	% nice but limiting in the possible linguistics possibilities
	ProofTree0 ::= leaf0 \ldata ProofRef \cross ProofInfo \rdata \\
			\t1 | node0 \ldata \seq_1~(\power_1~ProofTree0) \cross ProofInfo \rdata 
	\\
	% for optional intent? Or just use null for it axiomatically?
	OptPI ::= NonePI | Some \ldata ProofInfo \rdata
	\\
	ProofTree ::= Leaf \ldata ProofRef \cross OptPI \rdata \\ % or just ProofInto? 
			\t1 | Seq \ldata (ProofTree \cross ProofTree) \cross OptPI \rdata \\
			\t1 | Par \ldata (ProofTree \cross ProofTree) \cross OptPI \rdata \\
			\t1 | Decor \ldata ProofTree \cross OptPI \rdata \\ % useful for multi-layered intent
			%\t1 | whatever else....	
	\\
	ProofStatus ::= Axiom | Ignore | Qed | Unfinished
	\\
	AttemptKind ::= Blind | Guided | Because \ldata ProofTree \rdata | Clue \ldata ProofTree \rdata
\end{zed}

\begin{schema}{Attempt}
	intent: Intent \\
	desc: TEXT \\
	kind: AttemptKind \\
	pt: ProofTree
\end{schema}

\begin{schema}{Proof}
	atts: \seq_1~Attempt \\
	pstatus: ProofStatus \\
	label: NAME \\
	goal: TERM
\end{schema}

TODO/TOTHINK
* duplicate attempts (with the same proof script): ask the user if this is just a replay or a fresh new attempt. assume it's
  replay, leave the user to choose/config it

\end{document}